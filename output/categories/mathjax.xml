<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>weigl::io (mathjax)</title><link>http://www.student.kit.edu/~uiduw/</link><description></description><atom:link href="http://www.student.kit.edu/~uiduw/categories/mathjax.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Fri, 10 Jan 2014 03:22:47 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Elias Code Generation</title><link>http://www.student.kit.edu/posts/20130917-elias-code.html</link><description>&lt;p&gt;Simple python script for generating elias-&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;
, &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;
, unary and golomb codes.
Here is an example output with &lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;
, &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;
, and golomb-code.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ python elias.py
0: 0          : 0          : 0000000
1: 100        : 1000       : 0000001
2: 1100       : 11000      : 0000010
3: 1101       : 11001      : 0000011
4: 111000     : 110100     : 0000100
5: 111001     : 110101     : 0000101
6: 111010     : 110110     : 0000110
7: 111011     : 110111     : 0000111
8: 11110000   : 111000000  : 0001000
9: 11110001   : 111000001  : 0001001
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="link://listing/elias.py"&gt;elias.py&lt;/a&gt;&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="c"&gt;#!/usr/bin/python&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ceil&lt;/span&gt;

&lt;span class="n"&gt;log2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;fmt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'{0:0&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;b}'&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="s"&gt;'1'&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;'0'&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;elias_generic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lencoding&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;'0'&lt;/span&gt;
	
	&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
	&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
	
	&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lencoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;golomb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	
&lt;span class="n"&gt;elias_gamma&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;elias_generic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;elias_delta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;elias_generic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elias_gamma&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;	
	&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%5d&lt;/span&gt;&lt;span class="s"&gt;: &lt;/span&gt;&lt;span class="si"&gt;%-10s&lt;/span&gt;&lt;span class="s"&gt; : &lt;/span&gt;&lt;span class="si"&gt;%-10s&lt;/span&gt;&lt;span class="s"&gt; : &lt;/span&gt;&lt;span class="si"&gt;%-10s&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; \
		&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;elias_gamma&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;elias_delta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;golomb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;</description><category>NeuronalNet</category><category>KIT</category><category>mathjax</category><guid>http://www.student.kit.edu/posts/20130917-elias-code.html</guid><pubDate>Tue, 17 Sep 2013 16:35:00 GMT</pubDate></item><item><title>Dempster-Shafer-Theory</title><link>http://www.student.kit.edu/posts/20130405-dempster-shafer-theory.html</link><description>&lt;p&gt;I got bored. The result is a lousy implementation of the dempster recombination
rule (dcr) in dempster-shafer theory (dct).&lt;/p&gt;
&lt;p&gt;The dct describes system of base function to bind uncertainty to specific events
(similar to Kolgomorov axioms). But the formulation of uncertainty is a kind
easier.&lt;/p&gt;
&lt;p&gt;Let's say a sensor says A occurred and we trust the sensor to 60 %. We can
easily model this:&lt;/p&gt;
&lt;p&gt;$$ m(A)=0.6,m(\Omega)=0.4$$&lt;/p&gt;
&lt;p&gt;The event got 0.6 certainty, the rest got the 0.4. Notice that A⊂Ω (That the
difference to Kolgomorov). The axioms of dct for completeness:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$0 \le m(A) \le 1$ for every event A&lt;/li&gt;
&lt;li&gt;$ m(\emptyset)=0$&lt;/li&gt;
&lt;li&gt;$\sum_{A \subset \Omega} m(A) = 1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The difference to Kolgomorov is the third axiom. In the normal probability  the
sum over every distinct events $X$ must be the sum $P(X)$:&lt;/p&gt;
&lt;p&gt;$$P(\bigcup_i A_i = \sum_i P(A_i) $$&lt;/p&gt;
&lt;p&gt;We can define base measures with dcr rule:&lt;/p&gt;
&lt;p&gt;$$m_1 \oplus m_2 (A) = \begin{cases}\frac{\sum_{X \cap Y = A}
m_1(X)m_2(Y)}{1-\sum_{X \cap Y = 0} m_1(X)m_2(Y)} &amp;amp; else \ 
0 &amp;amp; A = \emptyset 
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;Additional we can define the function Bel for the degree of believe resp. Pl for
plausibility.&lt;/p&gt;
&lt;p&gt;$$ Bel(A) = \sum_{X \subseteq A} m(x) \qquad\qquad
   PlA) = \sum_{X \cap A \neq \emptyset} m(x)$$&lt;/p&gt;
&lt;p&gt;It follows: $0 \le Bel(A) \le Pl(A) \le 1$.
You can divide the interval $[0,1]$ into three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[0,Bel(A)]$  describes certainty of event $A$&lt;/li&gt;
&lt;li&gt;$[Bel(A),Pl(A)]$ describes the uncertainty of event $A$&lt;/li&gt;
&lt;li&gt;$[Pl(A),1]$  describes certainty that the event $A$ does not occurred&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example output:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;weigla@cook ~ % python drc.py
A: [m: 0.680000] [Bel 0.680000] [Pl 1.000000] ▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒
B: [m: 0.000000] [Bel 0.000000] [Pl 0.320000] ▒▒▒▒▒▒░░░░░░░░░░░░░░
C: [m: 0.000000] [Bel 0.000000] [Pl 0.320000] ▒▒▒▒▒▒░░░░░░░░░░░░░░
O: [m: 0.320000] [Bel 1.000000] [Pl 1.000000] ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓

A: [m: 0.438596] [Bel 0.438596] [Pl 0.438596] ▓▓▓▓▓▓▓▓░░░░░░░░░░░░
B: [m: 0.210526] [Bel 0.000000] [Pl 0.000000] ░░░░░░░░░░░░░░░░░░░░
C: [m: 0.350877] [Bel 0.000000] [Pl 0.000000] ░░░░░░░░░░░░░░░░░░░░
O: [m: 0.000000] [Bel 0.438596] [Pl 0.438596] ▓▓▓▓▓▓▓▓░░░░░░░░░░░░
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;drc.py:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;#-*- encoding: utf-8 -*-

class DictWrap(dict):
    def __call__(self,key): return self[key]

def drc(m1,m2):
    def appl(A):
        K = sum((m1(X)*m2(Y)
                for X in m1.keys()
                for Y in m2.keys()
                if len(X&amp;amp;Y) == 0))    
        if A:
            s = sum(( m1(X)*m2(Y)
                      for X in m1.keys()
                      for Y in m2.keys()
                      if X&amp;amp;Y == A))            
            return s/(1-K)
        else:
            return 0
    appl.keys = m1.keys
    return appl


def Pl(m, event):
    return sum( [m(X) for X in m.keys() 
                     if len(X &amp;amp; event) &amp;gt; 0])

def Bel(m,event):
    return sum( [m(X) for X in m.keys() 
                     if X &amp;lt;= event])

#events 
A = frozenset(('A',))
B = frozenset(('B',))
C = frozenset(('C',))
OMEGA = A | B | C

#example: two sensors
s1 = DictWrap({ A : 0.6, OMEGA: 0.4}) # s1 mesaures A with certainty of 60%
s2 = DictWrap({ A : 0.2, OMEGA: 0.8}) # s2 mesaures A with certainty of 20%

#combine
fusion = drc(s1,s2)
def show(text, event):
    print '%s: [m: %f] [Bel %f] [Pl %f]' % (text, 
                                       fusion(event),
                                       Bel(fusion,event), 
                                       Pl(fusion,event)),
    print_bar(Bel(fusion,event), Pl(fusion,event))

from math import ceil as round

def print_bar(bel, pl, width = 20):
    fbel = int(width * bel)
    fpl = int(width * pl)

a = fbel 
b = fpl - fbel 
c = width - fpl 
print ('▓' * a) + ('▒' * b) + ('░' * c)

show('A', A); show('B', B); show('C', C); show('O', OMEGA)

#combine 
s3 = DictWrap({ A: 0.2, B: 0.3, C: 0.5})
fusion = drc(fusion,s3)

show('A', A); show('B', B); show('C', C); show('O', OMEGA)
&lt;/pre&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://www.student.kit.edu/posts/20130405-dempster-shafer-theory.html</guid><pubDate>Wed, 03 Apr 2013 00:00:00 GMT</pubDate></item><item><title>Craig'sche Interpolation Lemma</title><link>http://www.student.kit.edu/posts/201210craigsche-interpolationslemma.html</link><description>&lt;p&gt;&lt;strong&gt;Satz:&lt;/strong&gt;
Seien $A,B$ zwei aussagenlogische Formeln und es gilt &lt;span class="math"&gt;\(\models A \Rightarrow B\)&lt;/span&gt;
 (Tautologie), dann existiert eine aussagenlogische Formeln $C$, sodass&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\models A \Rightarrow C \text{ und } \models C \Rightarrow B
\end{equation*}
&lt;/div&gt;
&lt;p&gt;wobei $C$ nur aus Konstanten $w,f$ und gemeinsamen Atome von $A,B$ besteht.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Beispiel:&lt;/em&gt; Nehmen wir an, dass &lt;span class="math"&gt;\(A := p \wedge q\)&lt;/span&gt;

und &lt;span class="math"&gt;\(B:= q \vee r\)&lt;/span&gt;
. Dann ist  $C := q$.&lt;/p&gt;
&lt;p&gt;Testen wir die Tautologien:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
p \wedge q \Rightarrow q \equiv~ \neg p \vee \neg q \vee q \equiv w
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
q~ \Rightarrow q \vee r \equiv~ \neg q \vee q \vee r \equiv w
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Beweis (konstrutiv):&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Erster Teil&lt;/em&gt; ($models A Rightarrow C$). Sei $C$ eine Disjunktion wie folgt:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
C := \bigvee A[c_1,\ldots, c_n]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;dabei ersetzen wir die Atome &lt;span class="math"&gt;\(P_1, \ldots, P_n\)&lt;/span&gt;
 aus $A$, die &lt;em&gt;nicht&lt;/em&gt; in $B$ vorkommen durch alle möglichen Kombinationen von Konstanten &lt;span class="math"&gt;\(c_1,\ldots,c_n \in \{w,f\}\)&lt;/span&gt;
. Für jede Interpretation $I$ mit $val_I(A) = w$ gilt: $val_I(C)=w$. Denn in der Disjunktion $C$ taucht jede mögliche Kombination der Wahrheitswerte von $P_i$ auf. Der Term der Disjunktion der $C$ wahr macht ist dieser mit:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A[c_1, \ldots, c_n] \text{ mit } c_i = val_I(P_i)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Zweiter Teil&lt;/em&gt; (&lt;span class="math"&gt;\(\models C \Rightarrow B\)&lt;/span&gt;
).&lt;/p&gt;
&lt;p&gt;Sei $I$ eine Interpretation mit $val_I(C) = w$. Dann ist mind. ein Term der
Disjunktion wahr. Wir konstruieren eine Hilfeinterpretation $J$ wie folgt:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J(P) =      \begin{cases}
            c_i &amp;amp; \colon  P = P_i \text{ für } 1\le i \le n \\
            I(P) &amp;amp; \colon \text{ sonst}
            \end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;$J$ ist ein Modell von $C$ und $A$. Nach Vorrausetzung (&lt;span class="math"&gt;\(A \Rightarrow B\)&lt;/span&gt;
) folgt
$val_J(B) = w$. Für alle Atome in $B$ trifft die Interpretation $J$ die gleiche
Aussage wie $I$. ($P_i$ waren die Atome aus &lt;span class="math"&gt;\(P_i \in A \wedge P_i \notin B\)&lt;/span&gt;
).
Also folgt $val_I(B) = w$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beispiel:&lt;/strong&gt; Zurück zu unseren Beispiel. Wie konstruieren das $C$ nun nachdem
Beweis.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
C := A[p=0] \vee A[p=1] \equiv (0 \wedge q) \vee (1 \wedge q) \equiv q
\end{equation*}
&lt;/div&gt;</description><category>mathjax</category><guid>http://www.student.kit.edu/posts/201210craigsche-interpolationslemma.html</guid><pubDate>Thu, 18 Oct 2012 00:00:00 GMT</pubDate></item></channel></rss>